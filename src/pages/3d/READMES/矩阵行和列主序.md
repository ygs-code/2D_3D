# 矩阵：行主序、列主序、行向量、列向量


## **行主序和列主序**

行主序指矩阵在内存中逐行存储，列主序指矩阵在内存中逐列存储。

行主序矩阵内存布局：

![](https://pic2.zhimg.com/80/v2-3d5cde0c897498f9a4bb0e71a060fb7d_1440w.webp)

列主序矩阵内存布局：

![](https://pic4.zhimg.com/80/v2-dc246d86c64f578189814522096201d3_1440w.webp)

## **行向量和列向量**

行向量指的是把向量当成一个一行n列的矩阵，列向量指的是把向量当成一个n行一列的矩阵。

## **左乘和右乘**

矩阵“左乘”：矩阵和向量相乘时放在左边。

矩阵“右乘”：矩阵和向量相乘时放在右边。

**对于同一个矩阵和同一个向量，“左乘”和“右乘”的结果是不一样的，这是因为矩阵不满足交换律。**

## **总结**

HLSL中默认是使用**列主序**存储矩阵的，也就是矩阵的每一列存储在一个常量寄存器中，此时使用矩阵“右乘”效率更高，因为一个float4和一个4x4的矩阵相乘只需要四个点乘就能计算出结果：

![](https://pic3.zhimg.com/80/v2-7b62a6da30b7e08a64d11203a93170aa_1440w.webp)

如果使用“左乘”，结果就是：

![](https://pic3.zhimg.com/80/v2-beb78b1db6eab9911950d83782c17dd6_1440w.webp)

HLSL中可以通过 **#pragmapack_matrix指令**或者 **row_major** 、**column_major keyword**来修改矩阵的存储方式。在Shader执行之前会加载矩阵的数据， **行主序还是列主序的设置只会影响Shader读取输入的矩阵数据** ， **矩阵读取到Shader后矩阵是行主序还是列主序就不会有其他影响（只会影响计算的效率）** ，比如通过代码获取某个元素的值，我们要获取第一行第三列的值，都是通过_m02来获取。

**但是为了使效率最高，对于列主序存储的矩阵我们要“右乘”，对于行主序存储的矩阵我们要“左乘”。**

因为DirectXMath中使用行主序矩阵，向量和矩阵相乘使用“左乘”，要想在Shader中读取正确的矩阵，我们就要转置一下，比如一个平移变换，在DirectXMath中是这样：

![](https://pic3.zhimg.com/80/v2-7ef3579035acc4f9ff27ef4deef053d2_1440w.webp)

矩阵“左乘”表示平移变换：

![](https://pic4.zhimg.com/80/v2-fda70ae530a4162bbd81cb1491a249ab_1440w.webp)

那在HLSL中使用的是列主序矩阵，我们使用“右乘”，要表示相同的平移变换，就要传入上面矩阵的转置矩阵：

![](https://pic3.zhimg.com/80/v2-77673e50dc8d0dc100388d33cc25091e_1440w.webp)

所以在把DirectXMath的矩阵传入HLSL时需要传入原矩阵的转置。








```text
行主序：在数组中按照a[0][0]、a[0][1]、a[0][2]…a[1][0]、a[1][1]、a[1][2]…依次存储数据
列主序：在数组中按照a[0][0]、a[1][0]、a[2][0]…a[0][1]、a[1][1]、a[2][1]…依次存储数据
基地址：即数组首元素地址，数组的起始地址。
```

布局应该是这样的

![](./images/7.png)




# 矩阵 – 行主序矩阵与列主序矩阵


## 1 线性代数中[矩阵](https://www.stubbornhuang.com/tag/%e7%9f%a9%e9%98%b5/ "浏览关于“矩阵”的文章")的标准定义

矩阵的标准定义：

> 矩阵A与B的乘积矩阵C的第i行第j列的元素c(ij)等于A的第i行与B的第j列的对应元素乘积的和。

无论是Direct3D或者OpenGL，所表示的矢量和矩阵都是依据线性代数中的标准定义的。

## 2 [行主序矩阵](https://www.stubbornhuang.com/tag/%e8%a1%8c%e4%b8%bb%e5%ba%8f%e7%9f%a9%e9%98%b5/ "浏览关于“行主序矩阵”的文章")与[列主序矩阵](https://www.stubbornhuang.com/tag/%e5%88%97%e4%b8%bb%e5%ba%8f%e7%9f%a9%e9%98%b5/ "浏览关于“列主序矩阵”的文章")

矩阵的存储方式分为两种，一种是行主序/行优先矩阵，另一种是列主序/列优先矩阵。在Direct3D中采用行主序矩阵存储矩阵，将矩阵每一行存储到数组的每一行中。而在OpenGL中采用列主序矩阵存储，将矩阵的每一列存储到数组的每一行中。

说的有点复杂，将下面矩阵示例：

1. 标准的线性代数矩阵

<pre class="vditor-reset" placeholder="" contenteditable="true" spellcheck="false"><p data-block="0"><img src="https://file+.vscode-resource.vscode-cdn.net/Users/admin/Documents/code/2D_3D/src/pages/3d/READMES/images/7.png" alt="" title=""/></p></pre>


2. Direct3D行主序矩阵


<pre class="vditor-reset" placeholder="" contenteditable="true" spellcheck="false"><div class="vditor-wysiwyg__block" data-type="html-block" data-block="0"><pre class="vditor-wysiwyg__preview" data-render="1"><pre class="vditor-reset" placeholder="" contenteditable="true" spellcheck="false"><p data-block="0"><img src="https://file+.vscode-resource.vscode-cdn.net/Users/admin/Documents/code/2D_3D/src/pages/3d/READMES/images/8.png" alt="" title=""/></p></pre></pre></div></pre>


3. OpenGL列主序矩阵

![](https://file+.vscode-resource.vscode-cdn.net/Users/admin/Documents/code/2D_3D/src/pages/3d/READMES/images/10.png)



## 3 由矩阵存储顺序引发的矩阵左乘/前乘或者右乘/后乘问题


从根本上来说，矩阵的定义是确定的，但是在不同的引擎的实现过程中对矩阵的存储方式选择了行主序矩阵或者列主序矩阵的存储方式，而由此引发了矩阵左乘或者是右乘的问题。

在线性代数中，矩阵乘法是“行*列”。

而对于行主序矩阵，通常采用前乘。
对于列主序矩阵，通常采用后乘。


## 由矩阵存储顺序引发的变换顺序问题

而这种矩阵乘法的顺序通常影响了对目标物体的变换顺序。
在OpenGL中，因为其实际上是列主序矩阵，采用列向量，所以在OpenGL中，做旋转变换时通常先处理右边的矩阵，然后再处理左边的矩阵。
在Direct3D中，因为其实际上是行主序矩阵，采用行向量，所以在Direct3D中，做旋转变换时通常先处理左边的矩阵，然后在处理右边的矩阵。
